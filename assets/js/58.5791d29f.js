(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{407:function(n,t,a){"use strict";a.r(t);var e=a(19),l=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"객체지향언어의-특징"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#객체지향언어의-특징"}},[n._v("#")]),n._v(" 객체지향언어의 특징")]),n._v(" "),a("ul",[a("li",[n._v("추상화(Abstraction)\n"),a("ul",[a("li",[n._v("구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 것")])])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("추상화(abstraction)라는 것은 미술의 '추상화'라는 것과 비슷한 개념이라고 보시면 됩니다. \n미술에서 추상화라는 것은 그 핵심요지만 살리고 나머지는 생략하거나 변형하는 방법으로 그린 그림을 뜻하는 것이라는 점은 알고 계시겠죠.\n마찬가지로 클래스를 구현함에 있어 모든 속성과 기능을 구현할 필요는 없습니다. \n'회사원 관리'를 위한 '사람' 클래스에서는 '성별'이라는 속성이 반드시 필요하지만 '남자목욕탕 회원 관리'를 위한 '사람' 클래스에서는 \n굳이 성별이라는 속성을 표시할 필요가 없습니다. 어차피 모든 구성원이 '남자'일테니깐요.\n이처럼 굳이 구현할 필요없는 부분을 과감히 생략하여 필요한 부분만을 나타내는 것을 추상화라고 합니다.\n")])])]),a("ul",[a("li",[n._v("캡슐화(Encapsulation)\n"),a("ul",[a("li",[a("strong",[n._v("정보 은닉")]),n._v("(information hiding): 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것")]),n._v(" "),a("li",[n._v("높은 응집도, 낮은 결합도를 유지하여 유연함과 유지보수성 증가")])])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("캡슐화(encapsulation)라는 것은 은닉화(hidden)라는 것과 비슷하지만 조금 차이가 있습니다. \n캡슐이라는 것은 약국에서 파는 알약 중에 '캡슐'에 들어가 있는 약을 생각하시면 됩니다. \n우리는 이 약을 복용할 때 그냥 캡슐채로 삼킬 뿐 그 안에 들어가 있는 알갱이 숫자를 세거나 구분해서 복용하지 않습니다. \n그냥 캡슐의 껍데기만 보고 무슨 약이라는 것을 알고 사용할 뿐입니다.\n\n마찬가지로 어떤 클래스를 사용함에 있어 그 클래스가 제공하는 메소드의 기능만을 알고 그 기능만을 사용할 뿐, 실제로 그 메소드가 어떻게 움직이는지는 굳이 알 필요가 없습니다. \nSystem.out.println()이라는 메소드를 쓰면 괄호 안의 내용이 출력된다는 사실만을 알면 되지 그것이 어떤 원리로 나오는지는 굳이 알 필요가 없는 것과 마찬가지입니다.\n\n은닉화라는 것은 이 캡슐화때문에 나오는 것인데 클래스의 속성들을 private으로 만들어 \n클래스 밖에서 함부로 건드리지 못하게 하는 것을 말합니다. \n클래스를 사용함에 있어 속성들에 직접 접근하는 것은 데이터 무결성 오류등에 치명적일 수 있기 때문에 이들을 접근하지 못하게 하고\n대신 '게터(getter)'와 '세터(setter)'라고 불리는 메소드를 통해서만 접근가능케 하는 것을 말합니다.\n\n이렇게 하면 초기에는 번거로워 보이지만 들어와서는 안될 데이터가 들어오는 것을 막을 수 있을 뿐 아니라 '객체 지향'이라는 의미에 보다 가깝게 접근하게 할 수 있습니다.\n")])])]),a("ul",[a("li",[n._v("상속(Inheritance)\n"),a("ul",[a("li",[n._v("여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정")])])])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("상속이라는 것은 말그대로 부모의 유산을 자식이 이어받듯이 부모클래스의 속성과 메소드를 자식클래스가 이어받는 것을 말합니다. \n자식클래스는 extends라는 키워드를 통해 상속받은 부모클래스의 모든 멤버변수와 메소드를 승계하여 자신의 것처럼 쓸 수 있습니다. \n단, 이 때 부모클래스에서 private으로 선언했다면 가지고는 있지만 사용은 불가능합니다. \n\n자바는 단일상속만을 지원하기 때문에 한 클래스가 여러클래스로부터 상속을 받는 것은 불가능하며 \n이러한 다중상속의 장점을 구현하기 위해 '인터페이스(interface)'를 사용합니다. \n")])])]),a("ul",[a("li",[n._v("다형성(Polymorphism)\n"),a("ul",[a("li",[n._v("서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력")]),n._v(" "),a("li",[n._v("오버라이딩(Overriding), 오버로딩(Overloading)")])])])])])}),[],!1,null,null,null);t.default=l.exports}}]);