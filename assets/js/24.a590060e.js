(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{339:function(n,t,a){n.exports=a.p+"assets/img/inheritance.d30173f1.png"},340:function(n,t,a){n.exports=a.p+"assets/img/inheritance1.393c8a1c.png"},402:function(n,t,a){"use strict";a.r(t);var r=a(19),e=Object(r.a)({},(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"상속-inheritance"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#상속-inheritance"}},[n._v("#")]),n._v(" 상속(inheritance)")]),n._v(" "),r("p",[r("em",[n._v("written by sohyeon, hyemin 💡")])]),n._v(" "),r("br"),n._v(" "),r("h2",{attrs:{id:"_1-상속의-정의와-장점"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-상속의-정의와-장점"}},[n._v("#")]),n._v(" 1.상속의 정의와 장점")]),n._v(" "),r("p",[n._v("상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다."),r("br"),n._v("\n상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다.")]),n._v(" "),r("ul",[r("li",[n._v("조상 클래스 : 상속해주는 클래스 ( 부모(parent)클래스, 상위(super)클래스, 기반(base)클래스 )")]),n._v(" "),r("li",[n._v("자손 클래스 : 상속 받는 클래스 ( 자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스 )")])]),n._v(" "),r("img",{attrs:{src:a(339),height:"80%",align:"center"}}),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("* 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.\n* 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.\n")])])]),r("img",{attrs:{src:a(340),height:"80%",align:"center"}}),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("* 클래스 Child와 Child2가 모두 Parent클래스를 상속받고 있다.\n* Parent클래스의 자손인 Child클래스와 Child2클래스는 조상의 멤버를 상속받기 때문에, Parent클래스에 새로운 멤버를 추가해주는 것은 Child클래스와 Child2클래스에 새로운 멤버를 추가해주는 것과 같은 효과다.\n* 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버도 함께 생성되기 때문에 따로 조상 클래스의 인스턴스를 생성하지 않고도 조상 클래스의 멤버들을 사용할 수 있다.\n")])])]),r("br"),n._v(" "),r("h2",{attrs:{id:"_2-클래스간의-관계-포함관계"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-클래스간의-관계-포함관계"}},[n._v("#")]),n._v(" 2. 클래스간의 관계 - 포함관계")]),n._v(" "),r("p",[n._v("상속이외에도 클래스를 재사용하는 방법으로는 클래스 간에 "),r("code",[n._v("포함(Composite)")]),n._v("관계를 맺어주는 것이다."),r("br"),n._v("\n클래스 간의 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("class Circle {\n    int x;  // 원점의 x좌표\n    int y;  // 원점의 y좌표\n    int r;  // 반지름(radius)\n}\n\nclass Point {\n    int x;  // 원점의 x좌표\n    int y;  // 원점의 y좌표\n}\n")])])]),r("p",[n._v("Point클래스를 재사용해서 Circle클래스를 작성한다.")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("class Circle {\n    Point c = new Point(); // 원점\n    int r;\n}\n")])])]),r("p",[n._v("단위별로 여러 개의 클래스를 작성한 다음, 이 단위 클래스들을 포함관계(멤버변수)로 재사용하면 보다 간결하고 손쉽게 클래스를 작성할 수 있다.")]),n._v(" "),r("br"),n._v(" "),r("h2",{attrs:{id:"_3-클래스간의-관계-결정하기"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-클래스간의-관계-결정하기"}},[n._v("#")]),n._v(" 3. 클래스간의 관계 결정하기")]),n._v(" "),r("p",[n._v("클래스를 작성하는데 있어서 상속관계를 맺어 줄 것인지 포함관계를 맺어 줄 것인지 결정하는 것은 때때로 혼돈스러울 수 있다.")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("상속관계 : '~은 ~이다.(is-a)'\n포함관계 : '~은 ~을 가지고 있다.(has-a)'\n")])])]),r("ul",[r("li",[n._v("Car클래스와 SportsCar클래스는 "),r("code",[n._v("SportsCar는 Car이다.")]),n._v(" (상속관계)")]),n._v(" "),r("li",[n._v("Card클래스와 Deck클래스는 "),r("code",[n._v("Deck은 Card를 가지고 있다.")]),n._v(" (포함관계)")])]),n._v(" "),r("h4",{attrs:{id:"ex-포함관계-예제"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ex-포함관계-예제"}},[n._v("#")]),n._v(" ex) 포함관계 예제")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('class DeckTest {\n    public static void main(String args[]) {\n        Deck d = new Deck();     // 카드 한 벌을 만든다.\n        Card c = d.pick(0);      // 섞기 전에 제일 위의 카드를 뽑는다. cardArr[0]에 저장된 Card객체의 주소가 참조변수 c에 저장\n        System.out.println(c);   // System.out.println(c.toString());과 같다.\n        \n        d.shuffle();             // 카드를 섞는다.\n        c = d.pick(0);           // 섞은 후에 제일 위의 카드를 뽑는다.\n        System.out.println(c); \n    }\n}\n\nclass Deck {\n    final int CARD_NUM = 52;     // 카드의 개수\n    Card cardArr[] = new Card[CARD_NUM];  // Card객체 배열을 포함\n    \n    Deck() {  // Deck의 카드를 초기화한다.\n        int i = 0;\n        \n        for(int k=Card.KIND_MAX; k>0; k--)      \n            for(int n=0; n<Card.NUM_MAX; n++)\n                cardArr[i++] = new Card(k, n+1);   \n    }\n    \n    Card pick(int index) {       // 지정된 위치에 있는 카드 하나를 꺼내서 반환\n        return cardArr[index];\n    }\n    \n    Card pick() {                // Deck에서 카드 하나를 선택한다.\n        int index = (int)(Math.random() * CARD_NUM);\n        return pick(intdex);\n    }\n    \n    void shuffle() {             // 카드의 순서를 섞는다.\n        for(int i=0; i < cardArr.length; i++) {\n            int r = (int)(Math.random() * CARD_NUM);\n    \n            Card temp = cardArr[i];\n            cardArr[i] = cardArr[r];\n            cardArr[r] = temp;\n        }\n    }\n}\n\nclass Card {\n    static final int KIND_MAX = 4;  // 카드 무늬의 수\n    static final int NUM_MAX = 13;  // 무늬별 카드 수\n\n    static final int SPACE = 4;\n    static final int DIAMOND = 3;\n    static final int HEART = 2;\n    static final int CLOVER = 1;\n    int kind;\n    int number;\n    \n    Card() {\n        this(SPACE, 1);\n    }\n    \n    Card(int kind, int number) {\n        this.kind = kind;\n        this.number = number;\n    }\n    \n    public String toString() {  // toString()은 인스턴스의 정보를 문자열로 반환할 목적으로 정의된 것\n        String[] kinds = {"", "CLOVER", "HEART", "DIAMOND", "SPACE"};\n        String numbers = "0123456789XJQK";\n        \n        return "kind : " + kinds[this.kind] + ", number : " + numbers.charAt(this.number);\n    }\n}\n')])])]),r("ul",[r("li",[n._v("toString( )은 모든 클래스의 조상인 Object클래스에 정의된 것으로, 어떤 종류의 객체에 대해서도 toString( ) 호출하는 것이 가능하다.")])]),n._v(" "),r("br"),n._v(" "),r("h2",{attrs:{id:"_4-단일-상속-single-inheritance"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-단일-상속-single-inheritance"}},[n._v("#")]),n._v(" 4. 단일 상속(single inheritance)")]),n._v(" "),r("ul",[r("li",[r("code",[n._v("자바")]),n._v("에서는 "),r("code",[n._v("단일상속")]),n._v("만을 허용한다.\n다중상속을 허용하면 여러 클래스로부터 상속받을 수 있기 때문에 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있다는 장점이 있지만, 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다는 단점을 가지고 있다.")])]),n._v(" "),r("br"),n._v(" "),r("h2",{attrs:{id:"_5-object-클래스-모든-클래스의-조상"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-object-클래스-모든-클래스의-조상"}},[n._v("#")]),n._v(" 5. Object 클래스 - 모든 클래스의 조상")]),n._v(" "),r("p",[r("code",[n._v("Object클래스")]),n._v("는 모든 클래스 상속계층도의 최상위에 있는 조상클래스"),r("br"),n._v("\n다른 클래스로부터 상속을 받는다고 하더라도 상속계층도를 따라 조상클래스, 조상클래스의 조상클래스를 찾아 올라가다 보면 결국 마지막 최상위 조상은 Object클래스일 것이다."),r("br"),n._v(" "),r("br")]),n._v(" "),r("h2",{attrs:{id:"reference-additional-resources"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reference-additional-resources"}},[n._v("#")]),n._v(" Reference & Additional Resources")])])}),[],!1,null,null,null);t.default=e.exports}}]);