(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{397:function(t,a,e){"use strict";e.r(a);var r=e(19),l=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"컬렉션-java-collections-framework"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#컬렉션-java-collections-framework"}},[t._v("#")]),t._v(" 컬렉션(Java Collections Framework)")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://madplay.github.io/img/post/2018-04-16-java-collection-synchronize-1.jpg",target:"_blank",rel:"noopener noreferrer"}},[e("img",{attrs:{src:"https://madplay.github.io/img/post/2018-04-16-java-collection-synchronize-1.jpg",alt:"img"}}),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[t._v("#")]),t._v(" Map")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("검색할 수 있는 인터페이스")])]),t._v(" "),e("li",[e("p",[t._v("순서가 없다.")])]),t._v(" "),e("li",[e("p",[t._v("많은 양의 데이터에서 원하는 특정 데이터에 접근(검색)할 때 사용한다.")])]),t._v(" "),e("li",[e("p",[t._v("데이터를 삽입할 때 Key와 Value의 형태로 삽입되며, Key를 이용해서 Value를 얻을 수 있다.")])]),t._v(" "),e("li",[e("p",[t._v("동일한 데이터를 Key값으로 사용할 수 없다. (단, key값이 다르고 value값이 동일한 것은 가능)")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("HashMap과 HashTable의 공통점과 차이점")])]),t._v(" "),e("ul",[e("li",[t._v("공통점 : 키(Key)와 값(Value)으로 데이터를 관리하며 키를 이용하여 데이터를 추출할 수 있다.")]),t._v(" "),e("li",[t._v("차이점 :  일반적으로 "),e("strong",[t._v("동기화")]),t._v("(Synchronization)가 필요 없다면 HashMap을, 동기화 보장이 필요하다면 Hashtable을 사용하면된다. HashMap과 Hashtable은 "),e("u",[t._v("동기화를 보장하느냐 하지 않느냐는 측면 이외에는 차이가 거의 없다")]),t._v(".\n"),e("ul",[e("li",[t._v("속도적인 측면에서도 구형이라 할 수 있는 Hashtable은 동기화 처리라는 비용때문에 HashMap에 비해 더 느리다고 한다.")]),t._v(" "),e("li",[t._v("한 자바 관련 서적에 의하면 Vector의 상위호환(?)개념인 ArrayList의 사용을 권장하듯 새로운 버전인 HashMap을 활용하고 동기화가 필요한 시점에서는 Java 5부터 제공하는 ConcurrentHashMap을 사용하는 것이 더 좋은 방법이라 표현한다.")])])])])])]),t._v(" "),e("h2",{attrs:{id:"collection"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#collection"}},[t._v("#")]),t._v(" Collection")]),t._v(" "),e("ul",[e("li",[t._v("List\n"),e("ul",[e("li",[t._v("순서가 있는 Collection")]),t._v(" "),e("li",[t._v("데이터를 중복해서 포함할 수 있다.")]),t._v(" "),e("li",[t._v("순차적으로 대량의 데이터를 억세스하거나 입력할때 사용한다.")]),t._v(" "),e("li",[e("strong",[t._v("Vector와 ArrayList의 차이점")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("Vector는 동기화가 이미 되어 있는 클래스")]),t._v("고 "),e("strong",[t._v("ArrayList는 동기화처리가 안된 클래스")]),t._v("이다.")]),t._v(" "),e("li",[e("strong",[t._v("Vector는 한 번에 하나의 쓰레드만 접근 가능")]),t._v("하며, "),e("strong",[t._v("ArrayList는 동시에 여러 쓰레드가 접근 가능")]),t._v("하다. (ArrayList에서 여러 쓰레드가 동시에 엑세스 해야하는 경우 개발자가 명시적으로 동기화코드를 추가하면 된다.)")]),t._v(" "),e("li",[t._v("멀티쓰레드 상황이 아닌 환경에선 "),e("em",[e("strong",[t._v("ArrayList가 더 빠르다")])]),t._v(".")])])])])]),t._v(" "),e("li",[t._v("Set\n"),e("ul",[e("li",[t._v("집합적인 개념의 Collection")]),t._v(" "),e("li",[t._v("순서의 의미가 없다.")]),t._v(" "),e("li",[t._v("데이터를 중복해서 포함할 수 없다.")]),t._v(" "),e("li",[t._v("순차적인 접근을 위해 Iterator를 사용한다.")])])])]),t._v(" "),e("h2",{attrs:{id:"collections-framework-선택-과정"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#collections-framework-선택-과정"}},[t._v("#")]),t._v(" Collections Framework 선택 과정")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("Map과 Collection 인터페이스 중 선택 1-1. Collection 선택 시 사용 목적에 따라 List와 Set중 선택")])]),t._v(" "),e("li",[e("p",[t._v("사용 목적에 따라 Map, List, Set 각각의 하위 구현체를 선택")]),t._v(" "),e("p",[t._v("2-1. Map: HashMap, LinkedHashMap, HashTable, TreeMap")]),t._v(" "),e("p",[t._v("2-2. List: LinkedList, ArrayList")]),t._v(" "),e("p",[t._v("2-3. Set: TreeSet, HashSet")])])]),t._v(" "),e("h2",{attrs:{id:"reference-additional-resources"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reference-additional-resources"}},[t._v("#")]),t._v(" Reference & Additional Resources")]),t._v(" "),e("ul",[e("li",[t._v("https://github.com/WeareSoft")]),t._v(" "),e("li",[t._v("https://madplay.github.io/post/java-collection-synchronize")]),t._v(" "),e("li",[t._v("https://odol87.tistory.com/3")])])])}),[],!1,null,null,null);a.default=l.exports}}]);